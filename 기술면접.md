[이벤트 루프](#이벤트-루프)
[CORS](#CORS)

# `CS`
## 프로세스 VS 스레드
스레드는 프로세스 안에 포함되어 있는 단위로 프로세스는 프로그램을 실행하는 순간 파일이 메모리에 올라가게 되고, 스레드는 더 작은 실행 단위 개념이다.  
프로세스는 메모리에 올라갈 때 운영체제로부터 독자적인 시스템 자원을 할당받는 반면, 스레드는 프로세스 내부에서 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유한다.

## 프로세스
운영체제가 프로그램의 실행을 위해 메모리를 할당하는 단위

## 스레드
프로세스가 할당받은 메모리를 실행하는 단위

### 싱글 스레드
하나의 프로세스에서 하나의 스레드 실행 (하나의 레지스터와 스택)
#### 장점
- 자원 접근에 대한 동기화를 고려하지 않아도 됨.
- 멀티 스레드에서 공유된 자원을 사용할 경우 접근 통제 등의 비용이 생기는데, 단일 스레드 모델은 이런 작업을 생략 가능함.
- 작업전환 작업을 요구하지 않음
> 작업전환 ?  
> 여러개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업 (**많은 비용 필요**)

#### 단점
- 여러개의 CPU를 활용하지 못함.
- 두개의 작업을 싱글 스레드, 멀티 스레드로 각각 처리할 때 후자의 경우 작업이 동시에 처리되는 것 처럼 보임.
  - 오히려 멀티스레드가 오랜 시간이 걸리는데 이는 스레드 간의 작업전환(Context Switching)에 시간이 걸리기 때문.

### 멀티 스레드
다수의 실행단위로 나누어 실행하여 프로세스 내의 자원을 공유하여 자원 생성, 관리의 중복을 최소화 (각 스레드마다 고유의 레지스터와 스택)
#### 장점
- 새로운 프로세스 생성보다 기존 프로세스에서 스레드를 생성하는 것이 더 빠름 (프로세스의 작업전환보다 스레드의 작업전환이 더 빠름)
- 프로세스의 자원과 상태를 공유하여 효율적
#### 단점
- 하나의 스레드만 실행할 땐 오히려 지연 (작업 전환)
- 멀티 스레딩을 위한 운영체제의 지원 필요
- 스레드 스케쥴링

## HTTP
`HyperText Transfer Protocol`의 약자로 데이터를 주고받기 위한 통신 프로토콜이다. (브라우저와 서버 간의 데이터 통신)
### 특징
- `stateless` 프로토콜
> stateless ?  
> 각각의 데이터 요청이 서로 독립적으로 관리된다는 말. (전에 보냈던 데이터와 다음에 보낼 데이터 요청이 관련이 없다)
- 이런 특징 때문에 서버에서 세션같은 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있음.
- HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며 포트는 80이다.
### `HTTP/1.1` VS `HTTP/2.0`
HTTP/1.1은 커넥션 당 하나의 요청과 응답만 처리
- HTML 문서 내에 포함된 `link`, `img`, `script` 태그 등의 리소스 요청이 개별적으로 전송된다.

동시 전송이 불가능한 구조이므로 리소스 개수에 비례해 응답 시간이 증가하는 **단점**  
HTTP/2.0는 커넥션 당 다중 요청/응답이 가능  
HTTP/1.1에 비해 페이지 로드 속도가 50% 정도 빠르다고 알려짐

### `HTTPS` VS `HTTP`
HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜 (443번 포트)  
네트워크 중간에 제 3자가 정보를 볼 수 없도록 **공개키 암호화**를 지원


## URL
URL(Uniform Resource Locators)은 서버에 자원을 요청하기 위해 입력하는 영문 주소.
IP보다 기억하기 쉽다는 장점이 있다.  
URL로 되어있는 HTTP 요청을 DNS(Domain Name Server)를 통해 Host에 해당하는 실제 IP 주소로 변환하여 서버에 요청합니다.
![img_2.png](img_2.png)

## 쿠키와 세션
### 왜 쓰나요?
HTTP는 항상 연결된 것이 아닌 필요할 때마다 요청/응답을 받는 **비연결성**이라는 특징이 있다.  
이는 클라이언트가 응답을 받으면 서버와의 접속이 끊기고, 연결이 끝나면 상태 정보가 유지되지 않는 특성이 있다. (stateless)
> 로그인 한 뒤, 다른 도메인으로 이동했다가 돌아오면 로그인 정보가 유지되지 않는다는 것  

### 쿠키
사이트가 이용하는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.
#### 특징
- 이름, 값, 만료일, 경로 정보
- 총 300개의 쿠키 저장 가능
- 하나의 도메인 당 20개
- 하나의 쿠키는 4KB(=4096byte)까지 저장 가능
#### 동작 순서
1. 클라이언트에서 페이지 요청 -> 웹 서버에서 쿠키 생성
2. 쿠키를 HTTP 화면을 돌려줄 때 클라이언트에게 전달
3. 로컬 PC에 쿠키를 저장하고 서버에 재요청 시 쿠키를 함께 전송
4. 클라이언트에서 쿠키가 있는 경우, 오청 페이지와 함께 쿠키를 전송
#### 약점
- 클라이언트에 저장 (보안 취약)

### 세션
클라이언트와 서버가 연결된 순간부터 브라우저를 닫아 HTTP 통신이 끝날 때까지의 기간이다.  
하지만 보통 세션이라고 하면 서버에 대한 정보(세션 상태, 클라이언트 상태, 세션 데이터)등을 저장하는 걸 의미하는 경우가 많다.

#### 특징
- 용량 제한이 없다.
- 웹 브라우저가 종료되면 세션 쿠키는 삭제
#### 동작 방식
1. 클라이언트가 페이지를 요청
2. 서버가 클라이언트마다 개별의 세션 ID 부여
3. 클라이언트는 요청 시마다 세션 ID 전달
4. 서버는 받은 세션 ID로 클라이언트 정보를 가져온다.

### 차이점
**1. 저장 위치**  
    - 쿠키: 클라이언트에 파일로 저장  
    - 세션: 서버에 저장  
**2. 보안**  
    - 쿠키: 클라이언트의 브라우저에 저장되기 때문에 보안에 취약  
    - 세션: 쿠키를 이용해 세션 ID만 저장하고 서버에서 처리하기 때문에 비교적 안전  
**3. 라이프 사이클**  
    - 쿠키: 만료시간이 있기 때문에 브라우저를 종료해도 남아있다.  
    - 세션: 만료기간을 정할 수는 있지만 브라우저가 종료되면 삭제

**4. 속도**  
    - 쿠키: 속도가 빠름  
    - 세션: 정보가 서버에 있기 때문에 비교적 느림

## CORS
Cross Origin Resource Sharing의 약자로 교차 출처 공유  
Origin은 1. scheme, 2. host, 3. port 로 이루어진 도메인을 말합니다.
```
https://www.naver.com/

1. scheme: https
2. host: www.naver.com
3. port: 
```
현재 출처에서 다른 출처의 API에 요청하게 되면 이 응답이 안전한지 판단하게 되는데, 응답을 보내는 출처가 다르더라도 요청을 허용해주는 응답 헤더를 보내 브라우저가 응답 결과를 보여줍니다.

**왜 부러우저가 CORS 요청을 처리하나요?**  
모든 서버들이 다 CORS를 인지하지 않기 때문에 서버가 안전하게 요청을 주고받을 수 있도록 브라우저에서 요청을 처리합니다.

**실제 요청에서는 어떻게 처리하나요?**  
같은 Origin에서 통신하는 경우엔 Request Header가 알아서 들어가지만, 교차 출처로 요청하는 상황에선 그렇지 않습니다.
```
프론트 > WithCredentials: true

서버 > Access-Control-Allow-Credentials: true
```

## SaaS
서비스로서의 소프트웨어(Software-as-a-Service)는 클라우드 애플리케이션과 기본 IT 인프라 및 플랫폼을 사용자에게 제공하는 클라우드 컴퓨팅 형태입니다.

## CI/CD
애플리케이션 개발 단계를 자동화하여 보다 짧은 주기로 고객에게 제공하는 방법. 기본 개념은 지속적인 통합, 지속적인 배포입니다.  
`CI`는 지속적인 통합을 의미합니다. 코드 변경 사항이 정기적으로 빌드 및 테스트되어 통합되므로 여러 개발자들과 동시에 개발할 경우 서로의 충돌을 해결할 수 있습니다.  
`CD`는 지속적인 배포를 의미합니다. 변경 사항이 버그 테스트를 거쳐 자동으로 업로드되고 프로덕션 환경까지 자동으로 릴리즈 되는 것을 의미합니다.

## 웹팩
가장 많이 사용되는 모듈 번들러 입니다.
> 모듈 번들러 ?  
> 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javascript, Images)을 모두 각각의 모듈로 보고 이를 조합하여 하나의 결과물을 만드는 도구
### 장점
1. 파일 단위의 자바스크립트 모듈 관리의 필요성
2. 웹 개발 작업 자동화 도구
3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능
### 주요 속성
1. entry
2. output
3. loader
4. plugin

`entry`
웹펙에서 자원을 변환하기 위해 최초 진입하는 곳이자 자바스크립트 파일 경로입니다. (빌드 대상 파일의 위치)
```javascript
// webpack.config.js
module.exports = {
    entry: './src/index.js'
};
```

`output`
웹팩을 돌리고 난 후 결과물의 파일 경로
```javascript
// webpack.config.js
module.exports = {
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, './dist')
    }
}
```

`loader`
로더는 자바스크립트 파일이 아닌 웹 자원(HTML, CSS, Images, 폰트 등)들을 빌드 시에 output 파일에 포함될 수 있도록 도와주는 속성

`plugin`
bundle.js에 css 파일을 같이 번들링 하는 것이 아닌 별도의 css 파일로 만들어주기 위해 플러그인을 사용

## 모듈
**특정 기능을 갖는 작은 코드 단위**를 의미합니다.
### 모듈 번들링
몇 백개의 자원들을 하나의 파일로 병합 및 압축해주는 동작을 모듈 번들링이라고 합니다.

## 바벨
자바스크립트에서 지원하는 최신 문법을 많은 브라우저 환경에서 호환되도록 트랜스파일링 해주는 언어
> 트랜스 파일?  
> 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환 (eg. es6 -> es5)

## 타입과 인터페이스
### 쓰는 이유
정적 타이핑을 지원한다는 점. 타입을 지정함으로써 프로그래밍 단계, HTTP 통신을 통한 데이터를 주고받는 과정에서 생기는 데이터를 안전하게 주고 받을 수 있다. 
또한 타입을 미리 선언해주기 때문에 타입과 관련된 프로토타입 메서드를 손쉽게 사용할 수 있다는 장점이 있다.
### 타입 VS 인터페이스
객체의 타입 이름을 지정하는 방법들이다.
1. 확장하는 방법  
인터페이스는 `extends` 키워드를 사용해 확장이 가능하고 타입은 `&` 연산자를 통해 확장이 가능하다.
```javascript
interface PeopleInterface {
    name: string;
    age: number;
}

interface StudentInterface extends PeopleInterface {
    school: string;
}

type PeopleType {
    name: string;
    age: number;
}

type StudentType = PeopleType & {
    school: string;
}
```

2. 선언적 확장  
인터페이스는 동일한 이름을 재정의함으로써 선언적 확장이 가능하지만, 타입은 불가능하다.
```javascript
interface Window {
    title: string;
}

intreface Window {
    ts: TypeScriptAPI;
}

type Window = {
    title: string;
}

type Window = {
    ts: TypeScriptAPI;
}

// Error
```

## 제네릭
클래스, 함수, 인터페이스 등을 다양한 타입으로 재사용가능하게 해주는 문법

# `자바스크립트`
## 프로그래밍
프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. 문제를 명확히 이해하고 적절한 해결 방은을 찾아 기계가 실행할 수 있을 정도로 요구를 설명하는 작업이며, 이 결과물이 바로 코드이다.

## 컴파일러와 인터프리터
프로그래밍 언어를 사용해 프로그램을 작성 후 컴퓨터가 이해할 수 있는 기계어로 변환해주는 번역기를 컴파일러(Compiler) 혹은 인터프리터(Interpreter)라고 한다.

## 자바스크립트의 특징
웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**이다. 
자바스크립트는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기 때문에 컴파일러 언어라고 할 수는 없다.

## 변수
변수는 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름을 말한다.

## 식별자
변수의 이름을 식별자(Identifier)라고도 한다. 식별자는 값이 아닌 메모리의 주소를 기억하고 있다. 변수 뿐만 아니라 함수, 클래스 등 메모리 상에 존재하는
값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

## 자바스크립트 타입
- Number
- String
- Boolean
- Object
- Symbol
- Function
- undefined
- BigInt..?
> null은 object 타입이다.  
> ![img.png](img.png)

## 스코프
### 함수 레벨 스코프
`var` 키워드로 선언한 경우 함수 레벨 스코프. 즉, 오로지 함수의 코드 블록만 지역 스코프로 인정합니다.
``

## task queue
콜 스택에 들어가기 전 setTimeout, 사용자 이벤트 콜백 등이 저장되는 큐

## microtask queue
Promise.then 콜백이 저장되는 큐

## 이벤트 루프 ?
### 정의
메인 스레드 동작 타이밍을 관리하는 관리자 역할. 메인 스레드란 자바스크립트 코드 실행이나 브라우저 렌더링을 맡는 등 브라우저의 주된 동작이 수행되는 곳이다.
### 중요한 이유
**1. 브라우저 동작의 대부분이 메인 스레드에서 싱글 스레드로 실행된다.**

브라우저 렌더링을 포함하여 비동기 함수를 제외한 대부분의 자바스크립트는 메인 스레드라는 곳에서 실행된다.

싱글 스레드가 하나의 작업을 하고 있다면 다른 작업은 지연시키게 된다. 메인 스레드에서도 마찬가지로 싱글 스레드 작업이 이루어지는 동안 다른 작업들을 지연시키기 때문에 싱글 스레드 작업 관리는 매우 중요하다.
> 브라우저의 탭 마다 다른 프로세스로 동작됩니다.

**2. 메인 스레드는 이벤드 루프에 의해 관리된다.**  
메인 스레드와 같은 싱글 스레드에서 하나의 작업이 오랫동안 실행되는 것을 방지하기 위해 어떤 작업을 우선으로 동작시킬 것인가 결정하는 것이 매우 중요하다.  

이러한 컨트롤을 이벤트 루프가 하는 것이다.

### 동작
1. 콜 스택에 쌓여있는 task 정리
2. microtask queue에 등록된 Promise.then 콜백 실행
3. 화면 갱신이 필요하다면 렌더링 파이프라인으로 이동
4. task queue의 콜백 하나씩 실행

[더보기](https://tecoble.techcourse.co.kr/post/2021-08-28-event-loop/)


## 블로킹 VS 논블로킹
파이썬은 블로킹 언어이고 자바스크립트는 논블로킹 언어입니다. 자바스크립트는 연산이 끝나는 것을 기다리지 않아도 되기 때문에 비동기적 작업이 가능합니다. 그래서 어떠한 작업이 끝나고 이뤄져야 하는 작업들은 `async/await` 나 콜백함수를 사용해야 합니다.

## 자바스크립트의 이벤트 루프
자바스크립트는 기본적으로 싱글 스레드 이벤트 루프 형태입니다.  
자바스크립트는 Stack과 Queue를 갖고 있는데 setTimeout 같은 함수들은 Queue(task queue)로 들어가게 되고, 그 메시지가 실행되어야하는 상황에 Stack이 비어있다면 실행 됩니다.

## Hosting
자바스크립트에서 선언문들이 최상위로 끌어올려지는 것을 의미합니다.
[더보기](JavaScript/호이스팅.md)

## 클로저
클로저란 자신이 생성될 때의 환경을 기억하는 함수로, 외부 변수를 기억하고 그 변수에 접근할 수 있는 함수를 뜻합니다.
자바스크립트는 중첩 함수로 쉽게 클로저를 구현할 수 있습니다.  
원래 함수 내부 변수를 스코핑할 때는 렉시컬 스코핑을 따라서 그 전역 변수에 있는 값을 참조하게 됩니다. 하지만, 함수 내부에
다른 함수를 위치시킴으로서 내부 함수가 감싸는 environment를 참조하게 되고, 값을 저장하는 것이 가능하게 됩니다.
```javascript
var color = 'red'; 
function foo() { 
    var color = 'blue'; // 2 
    function bar() { 
        console.log(color); // 1 'blue'
    } 
    return bar; 
} 
var baz = foo(); // 3 
baz(); // 4 undefined
```
[더보기](JavaScript/closure.md)

## This
자바스크립트는 `this`라는 객체를 갖게 되는데, `this`는 호출된 상황에서 함수를 소유하고 있는 객체를 의미합니다.
전역 환경에서 `this`를 쓰게 되면, 그것은 `window` 객체를 의미합니다.

> `apply`, `call`, `bind`를 통해 `this`를 주입 혹은 추출이 가능하다.

## async/await
자바스크립트에서 Promise를 쉽게 사용하기 위한 것으로 비동기 작업을 할 때 사용되고, 콜백 hell이나 무한 then과 같은 보기 안좋은 코드를 깔끔하게 표현할 수 있습니다.

#Refer
https://programming119.tistory.com/224?category=930152
